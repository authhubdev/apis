// @generated by protoc-gen-es v2.2.3 with parameter "target=ts"
// @generated from file auth/v1/session.proto (package auth.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { AuthTokens, SuccessResponse, UserInfo } from "./common_pb";
import { file_auth_v1_common } from "./common_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file auth/v1/session.proto.
 */
export const file_auth_v1_session: GenFile = /*@__PURE__*/
  fileDesc("ChVhdXRoL3YxL3Nlc3Npb24ucHJvdG8SB2F1dGgudjEiiAMKC1Nlc3Npb25JbmZvEhIKCnNlc3Npb25faWQYASABKAkSDwoHdXNlcl9pZBgCIAEoCRISCgppcF9hZGRyZXNzGAMgASgJEhIKCnVzZXJfYWdlbnQYBCABKAkSKAoLZGV2aWNlX3R5cGUYBSABKA4yEy5hdXRoLnYxLkRldmljZVR5cGUSMgoQb3BlcmF0aW5nX3N5c3RlbRgGIAEoDjIYLmF1dGgudjEuT3BlcmF0aW5nU3lzdGVtEg8KB2Jyb3dzZXIYByABKAkSFwoPYnJvd3Nlcl92ZXJzaW9uGAggASgJEhkKDGRldmljZV9tb2RlbBgJIAEoCUgAiAEBEhUKCGxvY2F0aW9uGAogASgJSAGIAQESEgoKY3JlYXRlZF9hdBgLIAEoAxIYChBsYXN0X2FjdGl2aXR5X2F0GAwgASgDEhIKCmV4cGlyZXNfYXQYDSABKAMSEgoKaXNfY3VycmVudBgOIAEoCEIPCg1fZGV2aWNlX21vZGVsQgsKCV9sb2NhdGlvbiIiChFHZXRTZXNzaW9uUmVxdWVzdBINCgV0b2tlbhgBIAEoCSJcChJHZXRTZXNzaW9uUmVzcG9uc2USJQoHc2Vzc2lvbhgBIAEoCzIULmF1dGgudjEuU2Vzc2lvbkluZm8SHwoEdXNlchgCIAEoCzIRLmF1dGgudjEuVXNlckluZm8iLgoVUmVmcmVzaFNlc3Npb25SZXF1ZXN0EhUKDXJlZnJlc2hfdG9rZW4YASABKAkiPQoWUmVmcmVzaFNlc3Npb25SZXNwb25zZRIjCgZ0b2tlbnMYASABKAsyEy5hdXRoLnYxLkF1dGhUb2tlbnMiXAoUUmV2b2tlU2Vzc2lvblJlcXVlc3QSFwoKc2Vzc2lvbl9pZBgBIAEoCUgAiAEBEhIKBXRva2VuGAIgASgJSAGIAQFCDQoLX3Nlc3Npb25faWRCCAoGX3Rva2VuIkEKFVJldm9rZVNlc3Npb25SZXNwb25zZRIoCgZyZXN1bHQYASABKAsyGC5hdXRoLnYxLlN1Y2Nlc3NSZXNwb25zZSJVChNMaXN0U2Vzc2lvbnNSZXF1ZXN0EhQKB3VzZXJfaWQYASABKAlIAIgBARISCgV0b2tlbhgCIAEoCUgBiAEBQgoKCF91c2VyX2lkQggKBl90b2tlbiJNChRMaXN0U2Vzc2lvbnNSZXNwb25zZRImCghzZXNzaW9ucxgBIAMoCzIULmF1dGgudjEuU2Vzc2lvbkluZm8SDQoFdG90YWwYAiABKAUihgEKGFJldm9rZUFsbFNlc3Npb25zUmVxdWVzdBIUCgd1c2VyX2lkGAEgASgJSACIAQESEgoFdG9rZW4YAiABKAlIAYgBARIZCgxrZWVwX2N1cnJlbnQYAyABKAhIAogBAUIKCghfdXNlcl9pZEIICgZfdG9rZW5CDwoNX2tlZXBfY3VycmVudCJcChlSZXZva2VBbGxTZXNzaW9uc1Jlc3BvbnNlEigKBnJlc3VsdBgBIAEoCzIYLmF1dGgudjEuU3VjY2Vzc1Jlc3BvbnNlEhUKDXJldm9rZWRfY291bnQYAiABKAUqiQEKCkRldmljZVR5cGUSGwoXREVWSUNFX1RZUEVfVU5TUEVDSUZJRUQQABIXChNERVZJQ0VfVFlQRV9ERVNLVE9QEAESFgoSREVWSUNFX1RZUEVfTU9CSUxFEAISFgoSREVWSUNFX1RZUEVfVEFCTEVUEAMSFQoRREVWSUNFX1RZUEVfT1RIRVIQBCr8AQoPT3BlcmF0aW5nU3lzdGVtEiAKHE9QRVJBVElOR19TWVNURU1fVU5TUEVDSUZJRUQQABIaChZPUEVSQVRJTkdfU1lTVEVNX01BQ09TEAESHAoYT1BFUkFUSU5HX1NZU1RFTV9XSU5ET1dTEAISGAoUT1BFUkFUSU5HX1NZU1RFTV9JT1MQAxIcChhPUEVSQVRJTkdfU1lTVEVNX0FORFJPSUQQBBIaChZPUEVSQVRJTkdfU1lTVEVNX0xJTlVYEAUSHQoZT1BFUkFUSU5HX1NZU1RFTV9DSFJPTUVPUxAGEhoKFk9QRVJBVElOR19TWVNURU1fT1RIRVIQBzKnAwoSQXV0aFNlc3Npb25TZXJ2aWNlEkUKCkdldFNlc3Npb24SGi5hdXRoLnYxLkdldFNlc3Npb25SZXF1ZXN0GhsuYXV0aC52MS5HZXRTZXNzaW9uUmVzcG9uc2USUQoOUmVmcmVzaFNlc3Npb24SHi5hdXRoLnYxLlJlZnJlc2hTZXNzaW9uUmVxdWVzdBofLmF1dGgudjEuUmVmcmVzaFNlc3Npb25SZXNwb25zZRJOCg1SZXZva2VTZXNzaW9uEh0uYXV0aC52MS5SZXZva2VTZXNzaW9uUmVxdWVzdBoeLmF1dGgudjEuUmV2b2tlU2Vzc2lvblJlc3BvbnNlEksKDExpc3RTZXNzaW9ucxIcLmF1dGgudjEuTGlzdFNlc3Npb25zUmVxdWVzdBodLmF1dGgudjEuTGlzdFNlc3Npb25zUmVzcG9uc2USWgoRUmV2b2tlQWxsU2Vzc2lvbnMSIS5hdXRoLnYxLlJldm9rZUFsbFNlc3Npb25zUmVxdWVzdBoiLmF1dGgudjEuUmV2b2tlQWxsU2Vzc2lvbnNSZXNwb25zZUIyWjBnaXRodWIuY29tL2F1dGhodWJkZXYvYXBpcy9nZW4vZ28vYXV0aC92MTthdXRodjFiBnByb3RvMw", [file_auth_v1_common]);

/**
 * SessionInfo contains information about an authentication session.
 *
 * @generated from message auth.v1.SessionInfo
 */
export type SessionInfo = Message<"auth.v1.SessionInfo"> & {
  /**
   * Unique identifier for the session.
   *
   * @generated from field: string session_id = 1;
   */
  sessionId: string;

  /**
   * User ID associated with the session.
   *
   * @generated from field: string user_id = 2;
   */
  userId: string;

  /**
   * IP address from which the session was created.
   *
   * @generated from field: string ip_address = 3;
   */
  ipAddress: string;

  /**
   * User agent information (browser, device, etc.).
   *
   * @generated from field: string user_agent = 4;
   */
  userAgent: string;

  /**
   * Device type (e.g., "Desktop", "Mobile", "Tablet").
   *
   * @generated from field: auth.v1.DeviceType device_type = 5;
   */
  deviceType: DeviceType;

  /**
   * Operating system (e.g., "macOS", "Windows", "iOS", "Android").
   *
   * @generated from field: auth.v1.OperatingSystem operating_system = 6;
   */
  operatingSystem: OperatingSystem;

  /**
   * Browser name (e.g., "Chrome", "Firefox", "Safari").
   *
   * @generated from field: string browser = 7;
   */
  browser: string;

  /**
   * Browser version (e.g., "115.0.5790").
   *
   * @generated from field: string browser_version = 8;
   */
  browserVersion: string;

  /**
   * Device model when available (e.g., "iPhone 14", "Pixel 7").
   *
   * @generated from field: optional string device_model = 9;
   */
  deviceModel?: string;

  /**
   * Location information based on IP address (e.g., "San Francisco, US").
   *
   * @generated from field: optional string location = 10;
   */
  location?: string;

  /**
   * Creation timestamp of the session.
   *
   * @generated from field: int64 created_at = 11;
   */
  createdAt: bigint;

  /**
   * Last activity timestamp for the session.
   *
   * @generated from field: int64 last_activity_at = 12;
   */
  lastActivityAt: bigint;

  /**
   * Expiration timestamp of the session.
   *
   * @generated from field: int64 expires_at = 13;
   */
  expiresAt: bigint;

  /**
   * Indicates whether this is the current active session.
   * This is useful when listing multiple sessions to identify the current one.
   *
   * @generated from field: bool is_current = 14;
   */
  isCurrent: boolean;
};

/**
 * Describes the message auth.v1.SessionInfo.
 * Use `create(SessionInfoSchema)` to create a new message.
 */
export const SessionInfoSchema: GenMessage<SessionInfo> = /*@__PURE__*/
  messageDesc(file_auth_v1_session, 0);

/**
 * GetSessionRequest contains the token to retrieve session information.
 *
 * @generated from message auth.v1.GetSessionRequest
 */
export type GetSessionRequest = Message<"auth.v1.GetSessionRequest"> & {
  /**
   * Authentication token for the session.
   * Must not be empty.
   *
   * @generated from field: string token = 1;
   */
  token: string;
};

/**
 * Describes the message auth.v1.GetSessionRequest.
 * Use `create(GetSessionRequestSchema)` to create a new message.
 */
export const GetSessionRequestSchema: GenMessage<GetSessionRequest> = /*@__PURE__*/
  messageDesc(file_auth_v1_session, 1);

/**
 * GetSessionResponse contains information about the session.
 *
 * @generated from message auth.v1.GetSessionResponse
 */
export type GetSessionResponse = Message<"auth.v1.GetSessionResponse"> & {
  /**
   * Session information.
   *
   * @generated from field: auth.v1.SessionInfo session = 1;
   */
  session?: SessionInfo;

  /**
   * User information associated with the session.
   *
   * @generated from field: auth.v1.UserInfo user = 2;
   */
  user?: UserInfo;
};

/**
 * Describes the message auth.v1.GetSessionResponse.
 * Use `create(GetSessionResponseSchema)` to create a new message.
 */
export const GetSessionResponseSchema: GenMessage<GetSessionResponse> = /*@__PURE__*/
  messageDesc(file_auth_v1_session, 2);

/**
 * RefreshSessionRequest contains the refresh token to get new auth tokens.
 *
 * @generated from message auth.v1.RefreshSessionRequest
 */
export type RefreshSessionRequest = Message<"auth.v1.RefreshSessionRequest"> & {
  /**
   * Refresh token received during previous authentication.
   * Must not be empty.
   *
   * @generated from field: string refresh_token = 1;
   */
  refreshToken: string;
};

/**
 * Describes the message auth.v1.RefreshSessionRequest.
 * Use `create(RefreshSessionRequestSchema)` to create a new message.
 */
export const RefreshSessionRequestSchema: GenMessage<RefreshSessionRequest> = /*@__PURE__*/
  messageDesc(file_auth_v1_session, 3);

/**
 * RefreshSessionResponse contains new authentication tokens.
 *
 * @generated from message auth.v1.RefreshSessionResponse
 */
export type RefreshSessionResponse = Message<"auth.v1.RefreshSessionResponse"> & {
  /**
   * New authentication tokens.
   *
   * @generated from field: auth.v1.AuthTokens tokens = 1;
   */
  tokens?: AuthTokens;
};

/**
 * Describes the message auth.v1.RefreshSessionResponse.
 * Use `create(RefreshSessionResponseSchema)` to create a new message.
 */
export const RefreshSessionResponseSchema: GenMessage<RefreshSessionResponse> = /*@__PURE__*/
  messageDesc(file_auth_v1_session, 4);

/**
 * RevokeSessionRequest contains information for revoking a session.
 *
 * @generated from message auth.v1.RevokeSessionRequest
 */
export type RevokeSessionRequest = Message<"auth.v1.RevokeSessionRequest"> & {
  /**
   * Session ID to revoke.
   * Either session_id or token must be provided.
   *
   * @generated from field: optional string session_id = 1;
   */
  sessionId?: string;

  /**
   * Authentication token for the session to revoke.
   * Either session_id or token must be provided.
   *
   * @generated from field: optional string token = 2;
   */
  token?: string;
};

/**
 * Describes the message auth.v1.RevokeSessionRequest.
 * Use `create(RevokeSessionRequestSchema)` to create a new message.
 */
export const RevokeSessionRequestSchema: GenMessage<RevokeSessionRequest> = /*@__PURE__*/
  messageDesc(file_auth_v1_session, 5);

/**
 * RevokeSessionResponse indicates the result of the session revocation.
 *
 * @generated from message auth.v1.RevokeSessionResponse
 */
export type RevokeSessionResponse = Message<"auth.v1.RevokeSessionResponse"> & {
  /**
   * Indicates whether the session was successfully revoked.
   *
   * @generated from field: auth.v1.SuccessResponse result = 1;
   */
  result?: SuccessResponse;
};

/**
 * Describes the message auth.v1.RevokeSessionResponse.
 * Use `create(RevokeSessionResponseSchema)` to create a new message.
 */
export const RevokeSessionResponseSchema: GenMessage<RevokeSessionResponse> = /*@__PURE__*/
  messageDesc(file_auth_v1_session, 6);

/**
 * ListSessionsRequest requests all active sessions for a user.
 *
 * @generated from message auth.v1.ListSessionsRequest
 */
export type ListSessionsRequest = Message<"auth.v1.ListSessionsRequest"> & {
  /**
   * User ID for which to list sessions.
   * If not provided, the user associated with the token will be used.
   *
   * @generated from field: optional string user_id = 1;
   */
  userId?: string;

  /**
   * Authentication token.
   * If user_id is not provided, this must be provided.
   *
   * @generated from field: optional string token = 2;
   */
  token?: string;
};

/**
 * Describes the message auth.v1.ListSessionsRequest.
 * Use `create(ListSessionsRequestSchema)` to create a new message.
 */
export const ListSessionsRequestSchema: GenMessage<ListSessionsRequest> = /*@__PURE__*/
  messageDesc(file_auth_v1_session, 7);

/**
 * ListSessionsResponse contains a list of active sessions.
 *
 * @generated from message auth.v1.ListSessionsResponse
 */
export type ListSessionsResponse = Message<"auth.v1.ListSessionsResponse"> & {
  /**
   * List of active sessions.
   *
   * @generated from field: repeated auth.v1.SessionInfo sessions = 1;
   */
  sessions: SessionInfo[];

  /**
   * Total number of active sessions.
   *
   * @generated from field: int32 total = 2;
   */
  total: number;
};

/**
 * Describes the message auth.v1.ListSessionsResponse.
 * Use `create(ListSessionsResponseSchema)` to create a new message.
 */
export const ListSessionsResponseSchema: GenMessage<ListSessionsResponse> = /*@__PURE__*/
  messageDesc(file_auth_v1_session, 8);

/**
 * RevokeAllSessionsRequest contains information for revoking all user sessions.
 *
 * @generated from message auth.v1.RevokeAllSessionsRequest
 */
export type RevokeAllSessionsRequest = Message<"auth.v1.RevokeAllSessionsRequest"> & {
  /**
   * User ID for which to revoke all sessions.
   * If not provided, the user associated with the token will be used.
   *
   * @generated from field: optional string user_id = 1;
   */
  userId?: string;

  /**
   * Authentication token.
   * If user_id is not provided, this must be provided.
   * This session will also be revoked unless keep_current is true.
   *
   * @generated from field: optional string token = 2;
   */
  token?: string;

  /**
   * If true, the current session (identified by token) will not be revoked.
   *
   * @generated from field: optional bool keep_current = 3;
   */
  keepCurrent?: boolean;
};

/**
 * Describes the message auth.v1.RevokeAllSessionsRequest.
 * Use `create(RevokeAllSessionsRequestSchema)` to create a new message.
 */
export const RevokeAllSessionsRequestSchema: GenMessage<RevokeAllSessionsRequest> = /*@__PURE__*/
  messageDesc(file_auth_v1_session, 9);

/**
 * RevokeAllSessionsResponse indicates the result of revoking all sessions.
 *
 * @generated from message auth.v1.RevokeAllSessionsResponse
 */
export type RevokeAllSessionsResponse = Message<"auth.v1.RevokeAllSessionsResponse"> & {
  /**
   * Indicates whether all sessions were successfully revoked.
   *
   * @generated from field: auth.v1.SuccessResponse result = 1;
   */
  result?: SuccessResponse;

  /**
   * Number of sessions revoked.
   *
   * @generated from field: int32 revoked_count = 2;
   */
  revokedCount: number;
};

/**
 * Describes the message auth.v1.RevokeAllSessionsResponse.
 * Use `create(RevokeAllSessionsResponseSchema)` to create a new message.
 */
export const RevokeAllSessionsResponseSchema: GenMessage<RevokeAllSessionsResponse> = /*@__PURE__*/
  messageDesc(file_auth_v1_session, 10);

/**
 * DeviceType represents the type of device used for authentication.
 *
 * @generated from enum auth.v1.DeviceType
 */
export enum DeviceType {
  /**
   * Default value for proto3
   *
   * @generated from enum value: DEVICE_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Desktop computer
   *
   * @generated from enum value: DEVICE_TYPE_DESKTOP = 1;
   */
  DESKTOP = 1,

  /**
   * Mobile phone
   *
   * @generated from enum value: DEVICE_TYPE_MOBILE = 2;
   */
  MOBILE = 2,

  /**
   * Tablet device
   *
   * @generated from enum value: DEVICE_TYPE_TABLET = 3;
   */
  TABLET = 3,

  /**
   * Other/unknown device type
   *
   * @generated from enum value: DEVICE_TYPE_OTHER = 4;
   */
  OTHER = 4,
}

/**
 * Describes the enum auth.v1.DeviceType.
 */
export const DeviceTypeSchema: GenEnum<DeviceType> = /*@__PURE__*/
  enumDesc(file_auth_v1_session, 0);

/**
 * OperatingSystem represents the operating system of the device.
 *
 * @generated from enum auth.v1.OperatingSystem
 */
export enum OperatingSystem {
  /**
   * Default value for proto3
   *
   * @generated from enum value: OPERATING_SYSTEM_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * macOS operating system
   *
   * @generated from enum value: OPERATING_SYSTEM_MACOS = 1;
   */
  MACOS = 1,

  /**
   * Windows operating system
   *
   * @generated from enum value: OPERATING_SYSTEM_WINDOWS = 2;
   */
  WINDOWS = 2,

  /**
   * iOS mobile operating system
   *
   * @generated from enum value: OPERATING_SYSTEM_IOS = 3;
   */
  IOS = 3,

  /**
   * Android mobile operating system
   *
   * @generated from enum value: OPERATING_SYSTEM_ANDROID = 4;
   */
  ANDROID = 4,

  /**
   * Linux operating system
   *
   * @generated from enum value: OPERATING_SYSTEM_LINUX = 5;
   */
  LINUX = 5,

  /**
   * ChromeOS operating system
   *
   * @generated from enum value: OPERATING_SYSTEM_CHROMEOS = 6;
   */
  CHROMEOS = 6,

  /**
   * Other/unknown operating system
   *
   * @generated from enum value: OPERATING_SYSTEM_OTHER = 7;
   */
  OTHER = 7,
}

/**
 * Describes the enum auth.v1.OperatingSystem.
 */
export const OperatingSystemSchema: GenEnum<OperatingSystem> = /*@__PURE__*/
  enumDesc(file_auth_v1_session, 1);

/**
 * AuthSessionService provides session management operations.
 *
 * @generated from service auth.v1.AuthSessionService
 */
export const AuthSessionService: GenService<{
  /**
   * GetSession retrieves information about the current authenticated session.
   * It validates the provided token and returns session details.
   *
   * @generated from rpc auth.v1.AuthSessionService.GetSession
   */
  getSession: {
    methodKind: "unary";
    input: typeof GetSessionRequestSchema;
    output: typeof GetSessionResponseSchema;
  },
  /**
   * RefreshSession generates new authentication tokens using a refresh token.
   * It validates the refresh token and issues a new access token.
   *
   * @generated from rpc auth.v1.AuthSessionService.RefreshSession
   */
  refreshSession: {
    methodKind: "unary";
    input: typeof RefreshSessionRequestSchema;
    output: typeof RefreshSessionResponseSchema;
  },
  /**
   * RevokeSession invalidates a specific session.
   * This can be used when a user logs out from a specific device.
   *
   * @generated from rpc auth.v1.AuthSessionService.RevokeSession
   */
  revokeSession: {
    methodKind: "unary";
    input: typeof RevokeSessionRequestSchema;
    output: typeof RevokeSessionResponseSchema;
  },
  /**
   * ListSessions returns all active sessions for a user.
   * This can be used to show users all devices where they're currently logged in.
   *
   * @generated from rpc auth.v1.AuthSessionService.ListSessions
   */
  listSessions: {
    methodKind: "unary";
    input: typeof ListSessionsRequestSchema;
    output: typeof ListSessionsResponseSchema;
  },
  /**
   * RevokeAllSessions invalidates all sessions for a user.
   * This can be used for security purposes or when a user wants to log out from all devices.
   *
   * @generated from rpc auth.v1.AuthSessionService.RevokeAllSessions
   */
  revokeAllSessions: {
    methodKind: "unary";
    input: typeof RevokeAllSessionsRequestSchema;
    output: typeof RevokeAllSessionsResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_auth_v1_session, 0);

